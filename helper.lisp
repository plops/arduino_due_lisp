(in-package :arv)

(defun .linear (a)
  (make-array (array-total-size a)
	      :element-type (array-element-type a)
	      :displaced-to a))

(defun .max (a)
  (reduce #'max (.linear a)))
(defun .min (a)
  (reduce #'min (.linear a)))

(defmethod average-images ((c camera) &key (number 100) (use-dark t))
  (let* ((a (acquire-single-image c))
	 (a1 (.linear a))
	 (accum (make-array (array-dimensions a)
			    :element-type '(unsigned-byte 32)
			    :initial-element 0))
	 (accum1 (.linear accum)))
    ;(push-buffer c)
    (format t "averaging ")
    (dotimes (i number)
      (format t ".")
      (progn 
	(progn (start-acquisition c)
	       (prog1 ;; acquire raw images
		   (pop-block-copy-push-buffer c :use-dark use-dark :out a)
		 (stop-acquisition c)))
	(dotimes (i (length a1))
	 (incf (aref accum1 i) (ash (aref a1 i) -4)))))
    (dotimes (i (length accum1))
      (setf (aref a1 i) (floor (* 16 (aref accum1 i)) number)))
    (terpri)
    a))

(defun .abs (a)
  (let* ((b (make-array (array-dimensions a) :element-type 'double-float))
	 (b1 (.linear b))
	 (a1 (.linear a)))
    (dotimes (i (length a1))
      (setf (aref b1 i) (abs (aref a1 i))))
    b))

(defun .abs* (a)
  (declare (type (array double-float 3) a))
  (let* ((b (make-array (butlast (array-dimensions a)) :element-type 'double-float))
	 (b1 (.linear b))
	 (a1 (.linear a)))
    (declare (type (array double-float 2) b)
	     (type (array double-float 1) b1 a1))
    (dotimes (i (length b1))
      (setf (aref b1 i) (abs (complex (aref a1 (* 2 i))
				      (aref a1 (+ 1 (* 2 i)))))))
    b))

(defun .log (a)
  (let* ((b (make-array (array-dimensions a) :element-type 'double-float))
	 (b1 (.linear b))
	 (a1 (.linear a)))
    (dotimes (i (length a1))
      (let ((v (aref a1 i)))
	(setf (aref b1 i) (if (= v 0d0)
			      0d0
			      (log v)))))
    b))

(defun .uint16 (a)
  (let* ((b (make-array (array-dimensions a) :element-type '(unsigned-byte 16)))
	 (b1 (.linear b))
	 (a1 (.linear a))
	 (ma (.max a))
	 (mi (.min a))
	 (s (if (< (- ma mi) 1e-3)
		1
		(/ 65535 (- ma mi)))))
    (dotimes (i (length a1))
      (setf (aref b1 i) (min 65535 (max 0 (floor (* s (- (aref a1 i) mi)))))))
    b))

(defun next-power-of-two (n)
  (expt 2 (ceiling (log n 2))))


(defun extract (a &key
                (x (floor (array-dimension a 1) 2))
                (y (floor (array-dimension a 0) 2))
                (w (next-power-of-two (min x y
                                           (- (array-dimension a 1) x)
                                           (- (array-dimension a 0) y))))
                (h w))
  (let* ((b1 (make-array (* h w) :element-type (array-element-type a)
                         :initial-element 0))
         (b (make-array (list h w)
                        :element-type (array-element-type a)
                        :displaced-to b1))
         (ox (- x (floor w 2)))
         (oy (- y (floor h 2))))
    ;(assert (<= 0 ox))
    ;(assert (<= 0 oy))
    ;(assert (< (+ w ox) (array-dimension a 1)))
    ;(assert (< (+ h oy) (array-dimension a 0)))
    (destructuring-bind (hh ww) (array-dimensions a)
     (dotimes (j h)
       (dotimes (i w)
	 (setf (aref b j i)
	       (aref a (mod (+ j oy) hh) (mod (+ i ox) ww))))))
    b))

(defun extract-cdf* (a &key
		     (x (floor (array-dimension a 1) 2))
		     (y (floor (array-dimension a 0) 2))
		     (w (next-power-of-two (min x y
						(- (array-dimension a 1) x)
						(- (array-dimension a 0) y))))
		     (h w))
  (declare (type (array double-float 3) a))
  (destructuring-bind (hh ww two) (array-dimensions a)
    (declare (ignore two))
    (let* ((b (make-array (list h w) :element-type '(complex double-float)))
	   (ox (- x (floor w 2)))
	   (oy (- y (floor h 2))))
      (declare (type (array (complex double-float) 2) b))
      (dotimes (j h)
       (dotimes (i w)
	 (setf (aref b j i) (complex (aref a (mod (+ j oy) hh) (mod (+ i ox) ww) 0)
				     (aref a (mod (+ j oy) hh) (mod (+ i ox) ww) 1)))))
     b)))

(defun .rr (a)
  (unless (or (arrayp a) (listp a))
    (error ".rr argument must be dimension list or array."))
  (let* ((dims (typecase a
		 (array (array-dimensions a))
		 (list a)))
	 (rank (length dims))
	 (b (make-array dims :element-type 'double-float)))
    (unless (= rank 2)
      (error "only rank 2 is supported for now"))
    (destructuring-bind (h w) dims
      (dotimes (j h)
	(dotimes (i w)
	  (setf (aref b j i) (sqrt (+ 0d0
				      (expt (/ (- i (floor w 2)) w) 2)
				      (expt (/ (- j (floor h 2)) h) 2)))))))
    b))

(defun .* (a b)
  (let* ((c (make-array (array-dimensions a)
			:element-type (array-element-type a)))
	 (c1 (.linear c))
	 (a1 (.linear a)))
    (typecase b
      (array (let ((b1 (.linear b)))
	       (dotimes (i (length c1))
		 (setf (aref c1 i) (* (aref a1 i) (aref b1 i))))))
      (number (dotimes (i (length c1))
		 (setf (aref c1 i) (* (aref a1 i) b)))))
    c))

(defun .+ (a b)
  (let* ((c (make-array (array-dimensions a)
			:element-type (array-element-type a)))
	 (c1 (.linear c))
	 (a1 (.linear a)))
    (typecase b
      (array (let ((b1 (.linear b)))
	       (dotimes (i (length c1))
		 (setf (aref c1 i) (+ (aref a1 i) (aref b1 i))))))
      (number (dotimes (i (length c1))
		 (setf (aref c1 i) (+ (aref a1 i) b)))))
    c))


(defun .phiphi (a)
  (unless (or (arrayp a) (listp a))
    (error ".phiphi argument must be dimension list or array."))
  (let* ((dims (typecase a
		 (array (array-dimensions a))
		 (list a)))
	 (rank (length dims))
	 (b (make-array dims :element-type 'double-float)))
    (unless (= rank 2)
      (error "only rank 2 is supported for now"))
    (destructuring-bind (h w) dims
      (dotimes (j h)
	(dotimes (i w)
	  (setf (aref b j i) (atan (* 1d0 (- j (floor h 2)))
				   (- i (floor w 2)))))))
    b))

(defun .mean (a)
  (let ((sum 0)
	(a1 (.linear a)))
    (dotimes (i (length a1))
      (incf sum (aref a1 i)))
    (/ sum (length a1))))

(defun write-pgm (filename img)
  (declare (type simple-string filename)
           ((array (unsigned-byte 16) 2) img)
           #+sbcl (values null &optional))
  (destructuring-bind (h w) (array-dimensions img)
    (declare (type fixnum w h))
    (with-open-file (s filename
                       :direction :output
                       :if-exists :supersede
                       :if-does-not-exist :create)
      (declare (stream s))
      (format s "P5~%~D ~D~%65535~%~%" w h))
    (with-open-file (s filename 
                       :element-type '(unsigned-byte 16)
                       :direction :output
                       :if-exists :append) ;; FIXME: i think this append doesn't work as expected and sometimes eats one of the new lines
      (let ((data-1d (make-array 
                      (* h w)
                      :element-type '(unsigned-byte 16)
                      :displaced-to img)))
        (write-sequence data-1d s)))
    nil))
